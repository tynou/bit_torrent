import aiohttp
import asyncio
import random
import struct
import socket
from urllib.parse import urlencode
from bencode import decode
from torrent import Torrent


class Tracker:
    def __init__(self, torrent: Torrent):
        self.torrent: Torrent = torrent
        self.peer_id: str = self._generate_peer_id()
        self.port: int = 6881  # Порт, который мы будем "слушать"
        self.session: aiohttp.ClientSession = aiohttp.ClientSession()

    def _generate_peer_id(self) -> str:
        # Генерируем уникальный ID для нашего клиента
        return "-PY0001-" + "".join(random.choice("0123456789") for _ in range(12))

    async def _get_peers_from_tracker(self, tracker_url, downloaded, uploaded, left):
        params = {
            "info_hash": self.torrent.info_hash,
            "peer_id": self.peer_id,
            "port": self.port,
            "uploaded": uploaded,
            "downloaded": downloaded,
            "left": left,
            "compact": 1,
            "event": "started",
        }

        url = tracker_url + ("&" if "?" in tracker_url else "?") + urlencode(params)

        try:
            async with self.session.get(url, timeout=10) as response:
                if response.status != 200:
                    print(f"Ошибка трекера {tracker_url}: {response.status}")
                    return None, None
                data = await response.read()
                tracker_response = decode(data)

                # Проверка на наличие ошибки от трекера
                if b"failure reason" in tracker_response:
                    print(
                        f"Ошибка от трекера {tracker_url}: {tracker_response[b'failure reason'].decode()}"
                    )
                    return None, None

                peers = self._parse_peers(tracker_response.get(b"peers", b""))
                interval = tracker_response.get(b"interval", 120)
                return peers, interval
        except (aiohttp.ClientError, asyncio.TimeoutError, ValueError) as e:
            print(f"Не удалось подключиться к трекеру {tracker_url}: {e}")
            return None, None

    # Новый метод, который будет вызываться из клиента
    async def get_peers(self, downloaded, uploaded, left):
        """Опрашивает все трекеры из torrent-файла и возвращает объединенный список пиров."""
        all_peers = set()
        min_interval = 60  # Интервал по умолчанию

        # Создаем задачи для опроса всех трекеров параллельно
        tasks = [
            self._get_peers_from_tracker(url, downloaded, uploaded, left)
            for url in self.torrent.trackers
        ]

        results = await asyncio.gather(*tasks)
        hardcoded_peers = [
            ("46.134.14.168", 4883),
            ("188.60.229.231", 8635),
            ("86.48.14.142", 50199),
            ("179.61.197.9", 55760),
            ("50.110.206.32", 41963),
            ("176.77.135.236", 38269),
            ("82.167.218.92", 6881),
            ("102.209.221.77", 14938),
            ("23.251.95.177", 1240),
            ("103.106.90.42", 11043),
            ("188.113.141.162", 36354),
            ("181.214.164.245", 62704),
            ("93.171.53.163", 63793),
            ("188.214.125.183", 15596),
            ("38.25.25.140", 43976),
            ("159.250.15.234", 19776),
            ("81.57.116.32", 36223),
            ("189.160.21.50", 6881),
            ("124.244.126.162", 50230),
            ("74.96.160.237", 33243),
            ("79.161.65.76", 58922),
            ("91.108.249.239", 42069),
            ("190.89.59.203", 22033),
            ("66.49.187.208", 3697),
            ("179.125.134.101", 47643),
            ("81.25.79.60", 19178),
            ("79.156.212.17", 56439),
            ("176.77.135.236", 5023),
            ("139.28.52.73", 33846),
            ("182.8.122.126", 43014),
            ("82.66.19.76", 7134),
            ("37.214.20.43", 1220),
            ("122.107.69.135", 9092),
            ("79.117.222.216", 6881),
            ("79.117.222.216", 57626),
            ("91.66.177.2", 9090),
            ("187.190.170.78", 34338),
            ("188.113.141.162", 22798),
            ("27.59.77.52", 1026),
            ("177.94.88.137", 42598),
            ("37.19.213.123", 1594),
            ("212.232.33.42", 60857),
            ("181.214.164.245", 15381),
            ("142.127.106.170", 40918),
            ("38.165.133.228", 37676),
            ("82.167.218.92", 8054),
            ("95.99.211.3", 33621),
            ("79.127.136.113", 54515),
            ("87.97.19.237", 62128),
            ("66.255.245.234", 2777),
            ("198.44.134.11", 22663),
            ("116.68.220.186", 6881),
            ("78.35.155.24", 6881),
            ("201.137.130.16", 57626),
            ("93.91.160.170", 31390),
            ("101.58.60.2", 13842),
            ("146.255.74.238", 5505),
            ("91.193.6.163", 23825),
            ("178.26.33.228", 6881),
            ("188.108.195.141", 36031),
            ("185.149.211.42", 51413),
            ("31.200.249.146", 31940),
            ("38.25.25.140", 17157),
            ("103.179.15.150", 58290),
            ("139.28.52.73", 64240),
            ("146.70.185.71", 56073),
            ("149.22.95.168", 22281),
            ("165.211.32.168", 58306),
            ("93.56.168.75", 64175),
            ("5.158.103.240", 59827),
            ("91.205.107.215", 38539),
            ("174.90.223.139", 1034),
            ("173.75.1.220", 44048),
            ("219.251.33.193", 40769),
            ("159.250.15.234", 47457),
            ("46.34.226.140", 6735),
            ("27.59.69.79", 11150),
            ("88.85.129.90", 52901),
            ("146.70.174.5", 55555),
            ("78.54.69.106", 29263),
            ("204.186.218.130", 23715),
            ("187.251.117.40", 6881),
            ("88.187.90.102", 36444),
            ("37.19.213.123", 38675),
            ("58.10.175.208", 2721),
            ("62.249.129.15", 1030),
            ("37.19.213.123", 11751),
            ("219.78.13.46", 64827),
            ("81.56.182.207", 49393),
            ("31.184.85.137", 51413),
            ("94.155.224.21", 37866),
            ("37.19.213.123", 17831),
            ("79.150.223.81", 6881),
            ("212.15.81.179", 39371),
            ("73.94.43.159", 15035),
            ("95.24.33.86", 51652),
            ("73.14.216.61", 13577),
            ("78.29.53.205", 2949),
            ("171.6.153.97", 11860),
            ("85.116.124.237", 23697),
            ("154.47.17.149", 41270),
            ("202.137.161.138", 25769),
            ("37.19.213.123", 14319),
            ("173.75.1.220", 44083),
            ("181.214.164.245", 10228),
            ("152.37.70.77", 62054),
            ("181.214.164.245", 3571),
            ("102.164.1.247", 46663),
            ("212.104.214.182", 44138),
            ("108.168.14.153", 54728),
            ("78.35.155.24", 57626),
            ("38.25.25.140", 54491),
            ("191.96.37.168", 60650),
            ("213.87.246.172", 48727),
            ("109.169.230.204", 37050),
            ("84.252.113.44", 50265),
            ("73.94.43.159", 59225),
            ("102.164.1.247", 39444),
            ("201.137.130.16", 6881),
            ("101.58.60.2", 4662),
            ("146.255.74.238", 33045),
            ("104.13.162.42", 17972),
            ("63.153.140.228", 26094),
            ("109.252.82.138", 3922),
            ("212.32.48.7", 14346),
            ("49.36.19.106", 13610),
            ("82.65.244.214", 47974),
            ("91.4.58.105", 46695),
            ("204.112.31.171", 12449),
            ("154.47.17.132", 32413),
            ("151.241.123.151", 48990),
            ("109.13.66.162", 42954),
            ("129.0.189.182", 5597),
            ("38.88.124.109", 43281),
            ("188.79.134.196", 48068),
            ("23.158.56.119", 9999),
            ("115.186.228.69", 6881),
        ]
        results = [(hardcoded_peers, 60)]
        # print(results)

        for peers, interval in results:
            if peers is not None:
                all_peers.update(peers)
            if interval is not None:
                min_interval = min(min_interval, interval)

        # Возвращаем список уникальных пиров и минимальный интервал
        return list(all_peers), min_interval

    def _parse_peers(self, peers_blob: bytes):
        # Пиры в компактном режиме: 6 байт на пира (4 байта IP, 2 байта порт)
        peers = []
        for i in range(0, len(peers_blob), 6):
            ip_bytes = peers_blob[i : i + 4]
            port_bytes = peers_blob[i + 4 : i + 6]
            ip = socket.inet_ntoa(ip_bytes)
            port = struct.unpack("!H", port_bytes)[0]
            peers.append((ip, port))
        return peers

    async def close(self):
        """Не забываем закрывать сессию при завершении работы клиента."""
        if not self.session.closed:
            await self.session.close()
